{"version":3,"sources":["getStateFromPath.tsx"],"names":["escape","queryString","getStateFromPath","path","options","undefined","initialRoutes","configs","concat","Object","keys","map","key","createNormalizedConfigs","result","current","remaining","replace","routeNames","params","config","match","paramPatterns","pattern","split","filter","p","startsWith","length","reduce","acc","i","value","parse","segments","decodeURIComponent","shift","join","state","routeName","initialRoute","findInitialRoute","createNestedState","nestedState","routes","index","query","route","parseFunction","findParseConfigForRoute","name","forEach","routeConfig","initials","push","createConfigItem","screens","initialRouteName","connectedRoutes","nestedConfig","pop","RegExp","flatConfig","includes","isEmpty"],"mappings":"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","sourcesContent":["import escape from 'escape-string-regexp';\nimport queryString from 'query-string';\nimport {\n  NavigationState,\n  PartialState,\n  InitialState,\n} from '@react-navigation/routers';\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype Options = {\n  [routeName: string]:\n    | string\n    | {\n        path?: string;\n        parse?: ParseConfig;\n        screens?: Options;\n        initialRouteName?: string;\n      };\n};\n\ntype RouteConfig = {\n  match: RegExp;\n  pattern: string;\n  routeNames: string[];\n  parse: ParseConfig | undefined;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  connectedRoutes: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * Example:\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     Chat: {\n *       path: 'chat/:author/:id',\n *       parse: { id: Number }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath(\n  path: string,\n  options: Options = {}\n): ResultState | undefined {\n  if (path === '') {\n    return undefined;\n  }\n  let initialRoutes: InitialRouteConfig[] = [];\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[]).concat(\n    ...Object.keys(options).map((key) =>\n      createNormalizedConfigs(key, options, [], initialRoutes)\n    )\n  );\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  let remaining = path\n    .replace(/[/]+/, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*/, ''); // Remove query params which we will handle later\n\n  while (remaining) {\n    let routeNames: string[] | undefined;\n    let params: Record<string, any> | undefined;\n\n    // Go through all configs, and see if the next path segment matches our regex\n    for (const config of configs) {\n      const match = remaining.match(config.match);\n\n      // If our regex matches, we need to extract params from the path\n      if (match) {\n        routeNames = [...config.routeNames];\n\n        const paramPatterns = config.pattern\n          .split('/')\n          .filter((p) => p.startsWith(':'));\n\n        if (paramPatterns.length) {\n          params = paramPatterns.reduce<Record<string, any>>((acc, p, i) => {\n            const key = p.replace(/^:/, '');\n            const value = match[i + 1]; // The param segments start from index 1 in the regex match result\n\n            acc[key] =\n              config.parse && config.parse[key]\n                ? config.parse[key](value)\n                : value;\n\n            return acc;\n          }, {});\n        }\n\n        // Remove the matched segment from the remaining path\n        remaining = remaining.replace(match[0], '');\n\n        break;\n      }\n    }\n\n    // If we hadn't matched any segments earlier, use the path as route name\n    if (routeNames === undefined) {\n      const segments = remaining.split('/');\n\n      routeNames = [decodeURIComponent(segments[0])];\n      segments.shift();\n      remaining = segments.join('/');\n    }\n\n    let state: InitialState;\n    let routeName = routeNames.shift() as string;\n    let initialRoute = findInitialRoute(routeName, initialRoutes);\n\n    state = createNestedState(\n      initialRoute,\n      routeName,\n      routeNames.length === 0,\n      params\n    );\n\n    if (routeNames.length > 0) {\n      let nestedState = state;\n\n      while ((routeName = routeNames.shift() as string)) {\n        initialRoute = findInitialRoute(routeName, initialRoutes);\n        nestedState.routes[nestedState.index || 0].state = createNestedState(\n          initialRoute,\n          routeName,\n          routeNames.length === 0,\n          params\n        );\n        if (routeNames.length > 0) {\n          nestedState = nestedState.routes[nestedState.index || 0]\n            .state as InitialState;\n        }\n      }\n    }\n\n    if (current) {\n      // The state should be nested inside the deepest route we parsed before\n      while (current?.routes[current.index || 0].state) {\n        current = current.routes[current.index || 0].state;\n      }\n\n      (current as PartialState<NavigationState>).routes[\n        current?.index || 0\n      ].state = state;\n    } else {\n      result = state;\n    }\n\n    current = state;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  const query = path.split('?')[1];\n\n  if (query) {\n    while (current?.routes[current.index || 0].state) {\n      // The query params apply to the deepest route\n      current = current.routes[current.index || 0].state;\n    }\n\n    const route = (current as PartialState<NavigationState>).routes[\n      current?.index || 0\n    ];\n\n    const params = queryString.parse(query);\n    const parseFunction = findParseConfigForRoute(route.name, configs);\n\n    if (parseFunction) {\n      Object.keys(params).forEach((name) => {\n        if (parseFunction[name] && typeof params[name] === 'string') {\n          params[name] = parseFunction[name](params[name] as string);\n        }\n      });\n    }\n\n    route.params = { ...route.params, ...params };\n  }\n\n  return result;\n}\n\nfunction createNormalizedConfigs(\n  key: string,\n  routeConfig: Options,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[]\n): RouteConfig[] {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(key);\n\n  const value = routeConfig[key];\n\n  if (typeof value === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    if (value !== '') {\n      configs.push(createConfigItem(routeNames, value));\n    }\n  } else if (typeof value === 'object') {\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (value.path && value.path !== '') {\n      configs.push(createConfigItem(routeNames, value.path, value.parse));\n    }\n    if (value.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (value.initialRouteName) {\n        initials.push({\n          initialRouteName: value.initialRouteName,\n          connectedRoutes: Object.keys(value.screens),\n        });\n      }\n      Object.keys(value.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          value.screens as Options,\n          routeNames,\n          initials\n        );\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n}\n\nfunction createConfigItem(\n  routeNames: string[],\n  pattern: string,\n  parse?: ParseConfig\n): RouteConfig {\n  const match = new RegExp(\n    '^' + escape(pattern).replace(/:[a-z0-9]+/gi, '([^/]+)') + '/?'\n  );\n\n  return {\n    match,\n    pattern,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n}\n\nfunction findParseConfigForRoute(\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n  return undefined;\n}\n\n// tries to find an initial route connected with the one passed\nfunction findInitialRoute(\n  routeName: string,\n  initialRoutes: InitialRouteConfig[]\n): string | undefined {\n  for (const config of initialRoutes) {\n    if (config.connectedRoutes.includes(routeName)) {\n      return config.initialRouteName === routeName\n        ? undefined\n        : config.initialRouteName;\n    }\n  }\n  return undefined;\n}\n\n// returns nested state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nfunction createNestedState(\n  initialRoute: string | undefined,\n  routeName: string,\n  isEmpty: boolean,\n  params?: Record<string, any> | undefined\n): InitialState {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, ...(params && { params }) },\n        ],\n      };\n    } else {\n      return {\n        routes: [{ name: routeName as string, ...(params && { params }) }],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [\n          { name: initialRoute },\n          { name: routeName as string, state: { routes: [] } },\n        ],\n      };\n    } else {\n      return { routes: [{ name: routeName as string, state: { routes: [] } }] };\n    }\n  }\n}\n"]}