{"version":3,"sources":["useLinking.tsx"],"names":["getStateLength","state","length","history","index","focusedState","routes","stale","isUsingLinking","useLinking","ref","config","getStateFromPath","getStateFromPathDefault","getPathFromState","getPathFromStateDefault","React","useEffect","Error","configRef","useRef","getStateFromPathRef","getPathFromStateRef","current","getInitialState","useCallback","path","location","pathname","search","undefined","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","window","addEventListener","navigation","previousHistoryIndex","historyIndex","getRootState","canGoBack","numberOfBacks","replaceState","i","goBack","action","dispatch","resetRoot","unsubscribe","addListener","previousStateLength","stateLength","l","pushState","delta","Math","min","go"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport { LinkingOptions } from './types';\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (isUsingLinking) {\n      throw new Error(\n        \"Looks like you are using 'useLinking' in multiple components. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Also ensure that you set your android activity launchMode to single task in your AndroiManifest.xml file.\"\n      );\n    } else {\n      isUsingLinking = true;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, getPathFromState, getStateFromPath]);\n\n  // Make it an async function to keep consistent with the native impl\n  const getInitialState = React.useCallback(async () => {\n    const path = location.pathname + location.search;\n\n    if (path) {\n      return getStateFromPathRef.current(path, configRef.current);\n    } else {\n      return undefined;\n    }\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    window.addEventListener('popstate', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    });\n  }, [ref]);\n\n  React.useEffect(() => {\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(\n          previousStateLength - stateLength,\n          // We need to keep at least one item in the history\n          // Otherwise we'll exit the page\n          previousHistoryIndexRef.current - 1\n        );\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta;\n\n          // If new entries were removed, go back so that we have same length\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({ index }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]}