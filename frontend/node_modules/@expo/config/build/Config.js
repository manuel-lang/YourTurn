"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const path_1 = __importDefault(require("path"));
const slugify_1 = __importDefault(require("slugify"));
const Errors_1 = require("./Errors");
const getConfig_1 = require("./getConfig");
const Modules_1 = require("./Modules");
const Project_1 = require("./Project");
/**
 * Get all platforms that a project is currently capable of running.
 *
 * @param projectRoot
 * @param exp
 */
function getSupportedPlatforms(projectRoot, exp) {
    const platforms = [];
    if (Modules_1.projectHasModule('react-native', projectRoot, exp)) {
        platforms.push('ios', 'android');
    }
    if (Modules_1.projectHasModule('react-native-web', projectRoot, exp)) {
        platforms.push('web');
    }
    return platforms;
}
function getConfigContext(projectRoot, options) {
    // TODO(Bacon): This doesn't support changing the location of the package.json
    const packageJsonPath = Modules_1.getRootPackageJsonPath(projectRoot, {});
    const pkg = json_file_1.default.read(packageJsonPath);
    const configPath = options.configPath || customConfigPaths[projectRoot];
    // If the app.json exists, we'll read it and pass it to the app.config.js for further modification
    const { configPath: appJsonConfigPath } = findConfigFile(projectRoot);
    let rawConfig = {};
    try {
        rawConfig = json_file_1.default.read(appJsonConfigPath, { json5: true });
        if (typeof rawConfig.expo === 'object') {
            rawConfig = rawConfig.expo;
        }
    }
    catch (err) {
        if (options.strict &&
            err.code !== 'ENOENT' // File not found. This is OK, because app.json is optional.
        ) {
            throw err;
        }
    }
    const { exp: configFromPkg } = ensureConfigHasDefaultValues(projectRoot, rawConfig, pkg, true);
    return {
        pkg,
        context: {
            projectRoot,
            configPath,
            config: configFromPkg,
        },
    };
}
/**
 * Evaluate the config for an Expo project.
 * If a function is exported from the `app.config.js` then a partial config will be passed as an argument.
 * The partial config is composed from any existing app.json, and certain fields from the `package.json` like name and description.
 *
 *
 * **Example**
 * ```js
 * module.exports = function({ config }) {
 *   // mutate the config before returning it.
 *   config.slug = 'new slug'
 *   return config;
 * }
 *
 * **Supports**
 * - `app.config.js`
 * - `app.config.json`
 * - `app.json`
 *
 * @param projectRoot the root folder containing all of your application code
 * @param options enforce criteria for a project config
 */
function getConfig(projectRoot, options = {}) {
    var _a;
    const { context, pkg } = getConfigContext(projectRoot, options);
    const config = (_a = getConfig_1.findAndEvalConfig(context), (_a !== null && _a !== void 0 ? _a : context.config));
    return Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, config, pkg, options.skipSDKVersionRequirement)), { rootConfig: config });
}
exports.getConfig = getConfig;
function getPackageJson(projectRoot) {
    // TODO(Bacon): This doesn't support changing the location of the package.json
    const packageJsonPath = Modules_1.getRootPackageJsonPath(projectRoot, {});
    return json_file_1.default.read(packageJsonPath);
}
exports.getPackageJson = getPackageJson;
function readConfigJson(projectRoot, skipValidation = false, skipNativeValidation = false) {
    const { configPath } = findConfigFile(projectRoot);
    let rawConfig = null;
    try {
        rawConfig = json_file_1.default.read(configPath, { json5: true });
    }
    catch (_) { }
    const { rootConfig, exp } = parseAndValidateRootConfig(rawConfig, skipValidation, projectRoot);
    const packageJsonPath = Modules_1.getRootPackageJsonPath(projectRoot, exp);
    const pkg = json_file_1.default.read(packageJsonPath);
    return Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipNativeValidation)), { rootConfig: rootConfig });
}
exports.readConfigJson = readConfigJson;
function readConfigJsonAsync(projectRoot, skipValidation = false, skipNativeValidation = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const { configPath } = findConfigFile(projectRoot);
        let rawConfig = null;
        try {
            rawConfig = yield json_file_1.default.readAsync(configPath, { json5: true });
        }
        catch (_) { }
        const { rootConfig, exp } = parseAndValidateRootConfig(rawConfig, skipValidation, projectRoot);
        const packageJsonPath = Modules_1.getRootPackageJsonPath(projectRoot, exp);
        const pkg = yield json_file_1.default.readAsync(packageJsonPath);
        return Object.assign(Object.assign({}, ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipNativeValidation)), { rootConfig: rootConfig });
    });
}
exports.readConfigJsonAsync = readConfigJsonAsync;
function findConfigFile(projectRoot) {
    const APP_JSON_FILE_NAME = 'app.json';
    let configPath;
    if (customConfigPaths[projectRoot]) {
        configPath = customConfigPaths[projectRoot];
    }
    else {
        configPath = path_1.default.join(projectRoot, APP_JSON_FILE_NAME);
    }
    return { configPath, configName: APP_JSON_FILE_NAME, configNamespace: 'expo' };
}
exports.findConfigFile = findConfigFile;
function configFilename(projectRoot) {
    return findConfigFile(projectRoot).configName;
}
exports.configFilename = configFilename;
function readExpRcAsync(projectRoot) {
    return __awaiter(this, void 0, void 0, function* () {
        const expRcPath = path_1.default.join(projectRoot, '.exprc');
        return yield json_file_1.default.readAsync(expRcPath, { json5: true, cantReadFileDefault: {} });
    });
}
exports.readExpRcAsync = readExpRcAsync;
const customConfigPaths = {};
function setCustomConfigPath(projectRoot, configPath) {
    customConfigPaths[projectRoot] = configPath;
}
exports.setCustomConfigPath = setCustomConfigPath;
const APP_JSON_EXAMPLE = JSON.stringify({
    expo: {
        name: 'My app',
        slug: 'my-app',
        sdkVersion: '...',
    },
});
function parseAndValidateRootConfig(rootConfig, skipValidation, projectRoot) {
    let outputRootConfig = rootConfig;
    if (outputRootConfig === null || typeof outputRootConfig !== 'object') {
        if (skipValidation) {
            outputRootConfig = { expo: {} };
        }
        else {
            throw new Errors_1.ConfigError(`Project at path ${path_1.default.resolve(projectRoot)} does not contain a valid app.json.`, 'NOT_OBJECT');
        }
    }
    const exp = outputRootConfig.expo;
    if (exp === null || typeof exp !== 'object') {
        throw new Errors_1.ConfigError(`Property 'expo' in app.json for project at path ${path_1.default.resolve(projectRoot)} is not an object. Please make sure app.json includes a managed Expo app config like this: ${APP_JSON_EXAMPLE}`, 'NO_EXPO');
    }
    return {
        exp: Object.assign({}, exp),
        rootConfig: Object.assign({}, outputRootConfig),
    };
}
function ensureConfigHasDefaultValues(projectRoot, exp, pkg, skipSDKVersionRequirement = false) {
    if (!exp)
        exp = {};
    if (!exp.name && typeof pkg.name === 'string') {
        exp.name = pkg.name;
    }
    if (!exp.description && typeof pkg.description === 'string') {
        exp.description = pkg.description;
    }
    if (!exp.slug && typeof exp.name === 'string') {
        exp.slug = slugify_1.default(exp.name.toLowerCase());
    }
    if (!exp.version && typeof pkg.version === 'string') {
        exp.version = pkg.version;
    }
    if (exp.nodeModulesPath) {
        exp.nodeModulesPath = path_1.default.resolve(projectRoot, exp.nodeModulesPath);
    }
    try {
        exp.sdkVersion = Project_1.getExpoSDKVersion(projectRoot, exp);
    }
    catch (error) {
        if (!skipSDKVersionRequirement)
            throw error;
    }
    if (!exp.platforms) {
        exp.platforms = getSupportedPlatforms(projectRoot, exp);
    }
    return { exp, pkg };
}
function writeConfigJsonAsync(projectRoot, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { configPath } = findConfigFile(projectRoot);
        let { exp, pkg, rootConfig } = yield readConfigJsonAsync(projectRoot);
        exp = Object.assign(Object.assign({}, rootConfig.expo), options);
        rootConfig = Object.assign(Object.assign({}, rootConfig), { expo: exp });
        yield json_file_1.default.writeAsync(configPath, rootConfig, { json5: false });
        return {
            exp,
            pkg,
            rootConfig,
        };
    });
}
exports.writeConfigJsonAsync = writeConfigJsonAsync;
const DEFAULT_BUILD_PATH = `web-build`;
function getWebOutputPath(config = {}) {
    var _a, _b, _c;
    if (process.env.WEBPACK_BUILD_OUTPUT_PATH) {
        return process.env.WEBPACK_BUILD_OUTPUT_PATH;
    }
    const expo = config.expo || config || {};
    return ((_c = (_b = (_a = expo) === null || _a === void 0 ? void 0 : _a.web) === null || _b === void 0 ? void 0 : _b.build) === null || _c === void 0 ? void 0 : _c.output) || DEFAULT_BUILD_PATH;
}
exports.getWebOutputPath = getWebOutputPath;
function getNameFromConfig(exp = {}) {
    // For RN CLI support
    const appManifest = exp.expo || exp;
    const { web = {} } = appManifest;
    // rn-cli apps use a displayName value as well.
    const appName = exp.displayName || appManifest.displayName || appManifest.name;
    const webName = web.name || appName;
    return {
        appName,
        webName,
    };
}
exports.getNameFromConfig = getNameFromConfig;
//# sourceMappingURL=Config.js.map