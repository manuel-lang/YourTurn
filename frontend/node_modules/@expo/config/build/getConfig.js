"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const json_file_1 = __importDefault(require("@expo/json-file"));
const jest_message_util_1 = require("jest-message-util");
const path_1 = __importDefault(require("path"));
const child_process_1 = require("child_process");
const Errors_1 = require("./Errors");
const Modules_1 = require("./Modules");
const Serialize_1 = require("./Serialize");
// support all common config types
exports.allowedConfigFileNames = (() => {
    const prefix = 'app';
    return [
        // order is important
        `${prefix}.config.ts`,
        `${prefix}.config.js`,
        `${prefix}.config.json`,
    ];
})();
function isMissingFileCode(code) {
    return ['ENOENT', 'MODULE_NOT_FOUND', 'ENOTDIR'].includes(code);
}
function reduceExpoObject(config) {
    if (!config)
        return null;
    if (typeof config.expo === 'object') {
        // TODO: We should warn users in the future that if there are more values than "expo", those values outside of "expo" will be omitted in favor of the "expo" object.
        return config.expo;
    }
    return config;
}
function findAndEvalConfig(request) {
    // TODO(Bacon): Support custom config path with `findConfigFile`
    // TODO(Bacon): Should we support `expo` or `app` field with an object in the `package.json` too?
    function testFileName(configFilePath) {
        if (!Modules_1.fileExists(configFilePath))
            return null;
        try {
            return evalConfig(configFilePath, request);
        }
        catch (error) {
            // If the file doesn't exist then we should skip it and continue searching.
            if (!isMissingFileCode(error.code)) {
                throw error;
            }
        }
        return null;
    }
    if (request.configPath) {
        const config = testFileName(request.configPath);
        if (config) {
            return reduceExpoObject(Serialize_1.serializeAndEvaluate(config));
        }
        else {
            throw new Errors_1.ConfigError(`Config with custom path ${request.configPath} couldn't be parsed.`, 'INVALID_CONFIG');
        }
    }
    for (const configFileName of exports.allowedConfigFileNames) {
        const configFilePath = path_1.default.resolve(request.projectRoot, configFileName);
        const config = testFileName(configFilePath);
        if (config)
            return reduceExpoObject(Serialize_1.serializeAndEvaluate(config));
    }
    return null;
}
exports.findAndEvalConfig = findAndEvalConfig;
// We cannot use async config resolution right now because Next.js doesn't support async configs.
// If they don't add support for async Webpack configs then we may need to pull support for Next.js.
function evalConfig(configFile, request) {
    if (configFile.endsWith('.json')) {
        return json_file_1.default.read(configFile, { json5: true });
    }
    else {
        try {
            const spawnResults = child_process_1.spawnSync('node', [
                require.resolve('@expo/config/build/scripts/read-config.js'),
                '--colors',
                configFile,
                JSON.stringify(Object.assign(Object.assign({}, request), { config: Serialize_1.serializeAndEvaluate(request.config) })),
            ], {});
            if (spawnResults.status === 0) {
                const spawnResultString = spawnResults.stdout.toString('utf8').trim();
                const logs = spawnResultString.split('\n');
                // Get the last console log to prevent parsing anything logged in the config.
                const lastLog = logs.pop();
                for (const log of logs) {
                    // Log out the logs from the config
                    console.log(log);
                }
                // Parse the final log of the script, it's the serialized config
                return JSON.parse(lastLog);
            }
            else {
                // Parse the error data and throw it as expected
                const errorData = JSON.parse(spawnResults.stderr.toString('utf8'));
                throw Errors_1.errorFromJSON(errorData);
            }
        }
        catch (error) {
            if (isMissingFileCode(error.code) || !(error instanceof SyntaxError)) {
                throw error;
            }
            const message = jest_message_util_1.formatExecError(error, { rootDir: request.projectRoot, testMatch: [] }, { noStackTrace: true }, undefined, true);
            throw new Errors_1.ConfigError(`\n${message}`, 'INVALID_CONFIG');
        }
    }
}
//# sourceMappingURL=getConfig.js.map